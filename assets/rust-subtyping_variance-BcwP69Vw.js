import{_ as d}from"./ValaxyMain.vue_vue_type_style_index_0_lang-CJwb-j0h.js";import{_ as p,u as c,c as m,w as t,p as h,o as f,a as e,b as n,d as s,r as l,e as g}from"./app-t0WzKcrM.js";import"./YunFooter.vue_vue_type_script_setup_true_lang-CJldLY-7.js";import"./YunCard.vue_vue_type_script_setup_true_lang-CgAMBqk4.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-CQr6kV1W.js";import"./index-C7yU5XnD.js";const A=JSON.parse('{"title":"Rust 的子类型化和变异性","description":"","frontmatter":{"title":"Rust 的子类型化和变异性","date":"2023-08-10T00:00:00.000Z","categories":["Rust"],"tags":["Rust"]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"SOLID 原则","slug":"solid-原则","link":"#solid-原则","children":[]},{"level":2,"title":"里氏替换原则","slug":"里氏替换原则","link":"#里氏替换原则","children":[]},{"level":2,"title":"子类型化和变异性","slug":"子类型化和变异性","link":"#子类型化和变异性","children":[]}],"relativePath":"pages/posts/rust-subtyping&variance.md","path":"/home/runner/work/xzc-blog/xzc-blog/pages/posts/rust-subtyping&variance.md","lastUpdated":1709257929000}'),i=JSON.parse('{"title":"Rust 的子类型化和变异性","description":"","frontmatter":{"title":"Rust 的子类型化和变异性","date":"2023-08-10T00:00:00.000Z","categories":["Rust"],"tags":["Rust"]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"SOLID 原则","slug":"solid-原则","link":"#solid-原则","children":[]},{"level":2,"title":"里氏替换原则","slug":"里氏替换原则","link":"#里氏替换原则","children":[]},{"level":2,"title":"子类型化和变异性","slug":"子类型化和变异性","link":"#子类型化和变异性","children":[]}],"relativePath":"pages/posts/rust-subtyping&variance.md","path":"/home/runner/work/xzc-blog/xzc-blog/pages/posts/rust-subtyping&variance.md","lastUpdated":1709257929000}'),b={name:"pages/posts/rust-subtyping&variance.md",data(){return{data:i,frontmatter:i.frontmatter,$frontmatter:i.frontmatter}},setup(){const a=c();a.meta.frontmatter=Object.assign(a.meta.frontmatter,i.frontmatter),h("pageData",i)}},_={id:"前言",tabindex:"-1"},v={id:"solid-原则",tabindex:"-1"},k=e("p",null,[n("记得大学学习编程时老师曾说，只有跨过面向对象的坎，才能算是入了编程的门。而我倒觉得对范式的理解并不是「跨过门槛」这么短时性的东西。不同编码水平的程序员对范式的理解是不同的，随着编码时长的增长，程序员对范式的理解会逐步增加，最终又会反过来提升编码水平。所以范式的学习应该是个 "),e("strong",null,"递进"),n(" 的过程。编程有很多种范式，其中面向对象（object-oriented programming）是经典中的经典。")],-1),S=e("p",null,"在我的理解里，范式本身是对前人编程经验的提炼及汇总。程序员们通过不断的使用面向对象范式，发现了一些有助于设计稳定、可维护和灵活的软件的准则，这就是大名鼎鼎的 SOLID 原则。其实就是几个原则的首字母缩写：",-1),y=e("ul",null,[e("li",null,[e("p",null,"单一职责原则（Single Responsibility Principle，SRP）： 一个类应该只有一个引起它变化的原因。这个原则强调每个类应该只负责单一的职责，以减少类的复杂性，增强可维护性。")]),e("li",null,[e("p",null,"开闭原则（Open/Closed Principle，OCP）： 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这个原则鼓励设计能够通过添加新功能来扩展，而不是修改现有代码。")]),e("li",null,[e("p",null,"里氏替换原则（Liskov Substitution Principle，LSP）： 子类应该能够替代基类，而不会影响程序的正确性。子类在继承基类时应该保持基类的行为和契约，以确保代码的稳定性。")]),e("li",null,[e("p",null,"接口隔离原则（Interface Segregation Principle，ISP）： 客户端不应该被迫依赖它不使用的接口。这个原则鼓励将大型接口分解为更小的、更专注的接口，以避免不必要的依赖和复杂性。")]),e("li",null,[e("p",null,"依赖倒置原则（Dependency Inversion Principle，DIP）： 高层模块不应该依赖于低层模块，二者都应该依赖于抽象。这个原则强调使用抽象接口或抽象类来进行解耦，以提高代码的可维护性和灵活性。")])],-1),P={id:"里氏替换原则",tabindex:"-1"},$=e("p",null,"开头提到的章节学习中，rust 的子类型化和变异性实际上有用到里氏替换原则，所以这里只对其进行进一步阐述，其余原则以后有时间再说。",-1),L=e("p",null,"LSP 可以从下面的观点推导出来：",-1),w=e("ul",null,[e("li",null,[e("p",null,"Subtyping（子类型化）关系： 继承是一种子类型化的关系。子类应该可以被当作父类来对待，因为它们共享了父类的行为和特征。这使得基类对象的代码可以在不知道具体子类的情况下正常工作。")]),e("li",null,[e("p",null,"Liskov Substitution（里氏替换）： 如果子类可以替代基类，那么基类对象的行为应该在不知道子类类型的情况下保持一致。子类不应该引入新的、与基类不一致的行为。")]),e("li",null,[e("p",null,"Behavioral Preservation（行为保持）： 子类应该保持基类的行为和契约。这意味着子类的方法应该遵循与基类相同的前置条件、后置条件和异常处理。")]),e("li",null,[e("p",null,"Expectation（期望）： 在使用基类对象的代码中，我们对于对象的行为有一定的期望。子类对象应该能够满足这些期望，以确保代码的正确性和稳定性。")])],-1),R={id:"子类型化和变异性",tabindex:"-1"};function O(a,D,I,B,o,N){const r=g,u=d;return f(),m(u,{frontmatter:o.frontmatter,data:o.data},{"main-content-md":t(()=>[e("h2",_,[n("前言 "),s(r,{class:"header-anchor",href:"#前言","aria-label":'Permalink to "前言"'},{default:t(()=>[n("​")]),_:1})]),e("p",null,[n("最近学习 rust 文档的 "),s(r,{href:"https://doc.rust-lang.org/reference/subtyping.html#subtyping-and-variance",target:"_blank",rel:"noreferrer"},{default:t(()=>[n("subtyping-and-variance")]),_:1}),n(" 时异常艰辛。个人感觉是因为之前一直在写前端，所以对面向对象的设计原则练习不够，最终导致学 rust 时的艰辛。这里简单记录一下学习这个章节时的学习笔记和个人总结。")]),e("h2",v,[n("SOLID 原则 "),s(r,{class:"header-anchor",href:"#solid-原则","aria-label":'Permalink to "SOLID 原则"'},{default:t(()=>[n("​")]),_:1})]),k,S,y,e("h2",P,[n("里氏替换原则 "),s(r,{class:"header-anchor",href:"#里氏替换原则","aria-label":'Permalink to "里氏替换原则"'},{default:t(()=>[n("​")]),_:1})]),$,e("p",null,[n("里氏替换原则由计算机科学家 Barbara Liskov 在 1987 年在一次会议上名为 (《数据的抽象与层次》)["),s(r,{href:"https://dl.acm.org/doi/pdf/10.1145/62139.62141",target:"_blank",rel:"noreferrer"},{default:t(()=>[n("https://dl.acm.org/doi/pdf/10.1145/62139.62141")]),_:1}),n("] 的演说中首先提出，并在 1994 年发表论文 (《A Behavioral Notion of Subtyping》)["),s(r,{href:"https://www.cs.cmu.edu/~wing/publications/LiskovWing94.pdf",target:"_blank",rel:"noreferrer"},{default:t(()=>[n("https://www.cs.cmu.edu/~wing/publications/LiskovWing94.pdf")]),_:1}),n("] 确定。该原则强调子类对象应该能够替换其基类（父类）对象，而不会影响程序的正确性。换句话说，子类应该是基类的有效扩展，而不是修改或破坏基类的行为。如果 S 是 T 的子类，那么在不破坏程序的正确性的前提下，任何针对 T 的程序都应该能够透明地使用 S 的对象。在遵循 LSP 的情况下，代码中使用基类对象的地方，在需要时将其替换为子类对象，代码不会出错。")]),L,w,e("h2",R,[n("子类型化和变异性 "),s(r,{class:"header-anchor",href:"#子类型化和变异性","aria-label":'Permalink to "子类型化和变异性"'},{default:t(()=>[n("​")]),_:1})]),e("p",null,[n("在这里再贴一下原文："),s(r,{href:"https://doc.rust-lang.org/reference/subtyping.html#subtyping-and-variance",target:"_blank",rel:"noreferrer"},{default:t(()=>[n("subtyping-and-variance")]),_:1})]),e("p",null,[n("找到了一篇讲的更详细的文档："),s(r,{href:"https://doc.rust-lang.org/nomicon/subtyping.html",target:"_blank",rel:"noreferrer"},{default:t(()=>[n("Subtyping and Variance")]),_:1})])]),"main-header":t(()=>[l(a.$slots,"main-header")]),"main-header-after":t(()=>[l(a.$slots,"main-header-after")]),"main-nav":t(()=>[l(a.$slots,"main-nav")]),"main-content":t(()=>[l(a.$slots,"main-content")]),"main-content-after":t(()=>[l(a.$slots,"main-content-after")]),"main-nav-before":t(()=>[l(a.$slots,"main-nav-before")]),"main-nav-after":t(()=>[l(a.$slots,"main-nav-after")]),comment:t(()=>[l(a.$slots,"comment")]),footer:t(()=>[l(a.$slots,"footer")]),aside:t(()=>[l(a.$slots,"aside")]),"aside-custom":t(()=>[l(a.$slots,"aside-custom")]),default:t(()=>[l(a.$slots,"default")]),_:3},8,["frontmatter","data"])}const J=p(b,[["render",O]]);export{A as __pageData,J as default};
